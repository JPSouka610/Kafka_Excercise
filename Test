import json
from producer_functions import (
    create_producer,
    processing_market_data,
    transformations
)
from sqlalchemy import create_engine
import time

def main_flow(interval=1, symbol="BTCUSDT", db_config=None, table_name="market_data"):
    """
    Flujo principal para obtener datos de mercado, procesarlos, transformarlos,
    y almacenarlos en la base de datos.

    Args:
        interval (int): Intervalo de tiempo (en segundos) entre cada solicitud a la API.
        symbol (str): Símbolo del par de mercado (e.g., BTCUSDT).
        db_config (dict): Configuración de la base de datos (usuario, contraseña, host, db).
        table_name (str): Nombre de la tabla en la base de datos.
    """
    try:
        # Crear conexión a la base de datos
        if not db_config:
            raise ValueError("La configuración de la base de datos es requerida.")

        engine = create_engine(
            f"postgresql://{db_config['user']}:{db_config['password']}@"
            f"{db_config['host']}/{db_config['db']}"
        )

        print("Conexión a la base de datos establecida.")

        # Flujo principal
        while True:
            # Obtener y procesar datos de mercado
            processed_data = processing_market_data(symbol=symbol)
            if processed_data is None:
                print("No se obtuvieron datos válidos. Intentando nuevamente...")
                time.sleep(interval)
                continue

            # Aplicar transformaciones adicionales
            transformed_data = transformations(processed_data)
            if transformed_data is None:
                print("Error al transformar los datos. Intentando nuevamente...")
                time.sleep(interval)
                continue

            # Guardar los datos en la base de datos
            try:
                transformed_data.to_sql(table_name, con=engine, if_exists="append", index=False)
                print(f"Datos almacenados en la tabla '{table_name}':")
                print(transformed_data)
            except Exception as db_error:
                print(f"Error al guardar los datos en la base de datos: {db_error}")

            # Esperar el intervalo antes de la próxima iteración
            time.sleep(interval)

    except KeyboardInterrupt:
        print("\nFlujo detenido manualmente.")
    except Exception as e:
        print(f"Error en el flujo principal: {e}")


if __name__ == "__main__":
    # Cargar configuración de la base de datos
    with open("db_credentials.json") as f:
        db_config = json.load(f)

    # Ejecutar flujo con un intervalo de 5 segundos
    main_flow(interval=5, symbol="BTCUSDT", db_config=db_config, table_name="market_data")
