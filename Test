def db_materialization(table_name, engine, json_df):
    """
    Materializa un DataFrame en una tabla de PostgreSQL, manejando duplicados y errores.
    """
    try:
        # Verificar si las columnas del DataFrame coinciden con las de la tabla
        with engine.connect() as conn:
            table_columns = conn.execute(f"""
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name = '{table_name}'
            """).fetchall()
            table_columns = [col[0] for col in table_columns]

        # Validar columnas del DataFrame
        missing_columns = set(json_df.columns) - set(table_columns)
        if missing_columns:
            raise ValueError(f"Las siguientes columnas están ausentes en la tabla '{table_name}': {missing_columns}")

        # Evitar duplicados basados en la columna 'timestamp'
        if "timestamp" in json_df.columns:
            with engine.connect() as conn:
                existing_timestamps = conn.execute(f"""
                    SELECT DISTINCT timestamp FROM {table_name};
                """).fetchall()
                existing_timestamps = {row[0] for row in existing_timestamps}
            
            # Filtrar filas que ya existen
            json_df = json_df[~json_df["timestamp"].isin(existing_timestamps)]

        # Insertar datos si hay filas nuevas
        if not json_df.empty:
            json_df.to_sql(table_name, con=engine, if_exists="append", index=False)
            print(f"Datos guardados exitosamente en la tabla '{table_name}'.")
        else:
            print(f"No hay datos nuevos para insertar en la tabla '{table_name}'.")

        return True

    except ValueError as ve:
        print(f"Error de validación: {ve}")
        return False
    except Exception as e:
        print(f"Error al guardar los datos en la tabla '{table_name}': {e}")
        return False

